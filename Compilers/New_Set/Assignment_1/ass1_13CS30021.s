	.file	"ass1_13CS30021.cpp"			#File name of the source .cpp file
	.section	.rodata						# Data section (read only)
.LC0:										#Label for 1st printf string
	.string	"Enter the order: "
.LC1:										#Label for 2nd printf string
	.string	"%d"
.LC2:										#Label for 3rd printf string
	.string	"Enter matix A in row-major: "
.LC3:										#Label for 4th printf string
	.string	"Enter matix B in row-major: "
.LC4:										#Label for 5th printf string
	.string	"The output matrix is:"
.LC5:										#Label for 6th printf string
	.string	"%d "
	
	.text									#Text Code Block begins
	.globl	main							#Main is a global name
	.type	main, @function					#Main is a function
main:										#Main Label
.LFB0:										#Local Labels auto generated, B for Begin and E for End
	.cfi_startproc							#Auto generated by GAS, cfi=Call Frame Information, used for exception handling
	pushq	%rbp							#Save old base pointer(q for quad word, difference between 32 bit and 64 bit architecture)
											#Use entire 64 bits of register(r prefix)
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp						#rbp <-- rsp sets the new base pointer
	.cfi_def_cfa_register 6
	subq	$4816, %rsp						#Space allocation for Matrix A, Matrix B, Matrix C and local variables.
											#Matrices A, B and C will take 20*20*4 each, i.e; 4800 and then i, j, n which will take 12 more
											# so as a result we have 4800+12 = 4812 and we take 4816 to align with 16
	movl	$.LC0, %edi						#%edi <-- $.LC0 (setting %edi to $.LCO)(move long)
	movl	$0, %eax						#Set %eax to 0(move long) for parameter for printf
	call	printf							#Call printf to print $.LC0
	leaq	-12(%rbp), %rax					#%rax is now the address location for n
	movq	%rax, %rsi 						#Set %rax (the address of n) to %rsi as 2nd parameter for scanf
	movl	$.LC1, %edi						#%edi <-- $.LC1 (setting %edi to $.LC1)(move long)
	movl	$0, %eax						#Set %eax to 0(move long) as parameter for scanf
	call	scanf							#Call scanf and store value in rsi(rax)
	movl	$.LC2, %edi						#%edi <-- $.LC2 (setting %edi to $.LC2)(move long)
	movl	$0, %eax						#Set %eax to 0(move long) for parameter for printf
	call	printf							#Call printf to print $.LC2
	movl	-12(%rbp), %eax					#Store the value of n in %eax
	leaq	-4816(%rbp), %rdx				#Store the starting for the matrix A address in %rdx
	movq	%rdx, %rsi 						#Starting memory address for Matrix A stored in %rsi
	movl	%eax, %edi						#Parameter n for the function moved from %eax to %edi
	call	_Z10ReadMatrixiPA20_i			#Fuction call for Read Matrix for A with order n
	movl	$.LC3, %edi						#%edi <-- $.LC3 (setting %edi to $.LC3)(move long)
	movl	$0, %eax						#Set %eax to 0(move long) for parameter for printf
	call	printf							#Call printf to print $.LC3
	movl	-12(%rbp), %eax					#Store the value of n in %eax
	leaq	-3216(%rbp), %rdx				#Store the starting for the matrix B address in %rdx
	movq	%rdx, %rsi 						#Starting memory address for Matrix B stored in %rsi
	movl	%eax, %edi						#Parameter n for the function moved from %eax to %edi
	call	_Z10ReadMatrixiPA20_i			#Fuction call for Read Matrix for B with order n
	movl	-12(%rbp), %eax					#Store the value of n in %eax
	leaq	-1616(%rbp), %rcx				#Store the starting for the matrix C(multiplication result)
	leaq	-3216(%rbp), %rdx				#Store the starting for the matrix B address in %rdx
	leaq	-4816(%rbp), %rsi 				#Store the starting for the matrix A address in %rdx
	movl	%eax, %edi						#Parameter n for the function moved from %eax to %edi
	call	_Z14MultiplyMatrixiPA20_iS0_S0_	#Function Call For Multiplication with parameters resultant matrix, Mat(A), Mat(B), n
	movl	$.LC4, %edi						#%edi <-- $.LC4 (setting %edi to $.LC4)(move long)
	call	puts							#Print strinf stored in LC4
	movl	$0, -8(%rbp)					#Set i to 0
	jmp	.L2									#Jump to Label L2
.L5:										#Label L5 starts
	movl	$0, -4(%rbp)					#Set j to 0
	jmp	.L3									#Jump to Line L3
.L4:										#Label L4 starts
	movl	-4(%rbp), %eax					#Store the value of j in %eax
	movslq	%eax, %rcx						#Convert j to 64-bit and store in %rcx
	movl	-8(%rbp), %eax					#Store the value of i in %eax
	movslq	%eax, %rdx						#Convert i to 64-bit and store in %rdx
	movq	%rdx, %rax						#Move value of i from %rdx to %rax
	salq	$2, %rax						#%rax Left shift twice(Multiply by 4)
	addq	%rdx, %rax						#%rax += %rdx
	salq	$2, %rax						#%rax Left shift twice(Multiply by 4)
	addq	%rcx, %rax						
	movl	-1616(%rbp,%rax,4), %eax			
	movl	%eax, %esi						
	movl	$.LC5, %edi							
	movl	$0, %eax						
	call	printf							
	addl	$1, -4(%rbp)					
.L3:										
	movl	-12(%rbp), %eax						
	cmpl	%eax, -4(%rbp)					
	setl	%al 							
	testb	%al, %al 							
	jne	.L4									
	movl	$10, %edi						
	call	putchar								
	addl	$1, -8(%rbp)						
.L2:										
	movl	-12(%rbp), %eax					
	cmpl	%eax, -8(%rbp)					
	setl	%al 								
	testb	%al, %al 							
	jne	.L5									
	movl	$0, %eax						
	leave									
	.cfi_def_cfa 7, 8						
	ret 									
	.cfi_endproc								
.LFE0:										#Reached end of auto generated label
	.size	main, .-main 					
	.section	.rodata						
.LC6:										
	.string	"The input matrix is:"				
	.text 									
	.globl	_Z10ReadMatrixiPA20_i			
	.type	_Z10ReadMatrixiPA20_i, @function
_Z10ReadMatrixiPA20_i:						
.LFB1:											
	.cfi_startproc								
	pushq	%rbp							
	.cfi_def_cfa_offset 16					
	.cfi_offset 6, -16						
	movq	%rsp, %rbp							
	.cfi_def_cfa_register 6						
	subq	$32, %rsp							
	movl	%edi, -20(%rbp)						
	movq	%rsi, -32(%rbp)						
	movl	$0, -8(%rbp)						
	jmp	.L7										
.L10:												
	movl	$0, -4(%rbp)					
	jmp	.L8											
.L9:												
	movl	-8(%rbp), %eax						
	movslq	%eax, %rdx							
	movq	%rdx, %rax							
	salq	$2, %rax									
	addq	%rdx, %rax									
	salq	$4, %rax							
	addq	-32(%rbp), %rax						
	movl	-4(%rbp), %edx						
	movslq	%edx, %rdx							
	salq	$2, %rdx							
	addq	%rdx, %rax						
	movq	%rax, %rsi 							
	movl	$.LC1, %edi							
	movl	$0, %eax						
	call	scanf								
	addl	$1, -4(%rbp)						
.L8:																					
	movl	-4(%rbp), %eax							
	cmpl	-20(%rbp), %eax					
	setl	%al 								
	testb	%al, %al 								
	jne	.L9														
	addl	$1, -8(%rbp)								
.L7:																
	movl	-8(%rbp), %eax											
	cmpl	-20(%rbp), %eax											
	setl	%al 										
	testb	%al, %al 							
	jne	.L10									
	movl	$.LC6, %edi							
	call	puts								
	movl	$0, -8(%rbp)						
	jmp	.L11									
.L14:												
	movl	$0, -4(%rbp)						
	jmp	.L12										
.L13:												
	movl	-8(%rbp), %eax							
	movslq	%eax, %rdx								
	movq	%rdx, %rax								
	salq	$2, %rax								
	addq	%rdx, %rax							
	salq	$4, %rax								
	addq	-32(%rbp), %rax												
	movl	-4(%rbp), %edx								
	movslq	%edx, %rdx							
	movl	(%rax,%rdx,4), %eax			
	movl	%eax, %esi
	movl	$.LC5, %edi
	movl	$0, %eax
	call	printf
	addl	$1, -4(%rbp)
.L12:
	movl	-4(%rbp), %eax
	cmpl	-20(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L13
	movl	$10, %edi
	call	putchar
	addl	$1, -8(%rbp)
.L11:
	movl	-8(%rbp), %eax
	cmpl	-20(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L14
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	_Z10ReadMatrixiPA20_i, .-_Z10ReadMatrixiPA20_i
	.section	.rodata
.LC7:
	.string	"The transposed matrix is:"
	.text
	.globl	_Z15TransposeMatrixiPA20_i
	.type	_Z15TransposeMatrixiPA20_i, @function
_Z15TransposeMatrixiPA20_i:
.LFB2:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$32, %rsp
	movl	%edi, -20(%rbp)
	movq	%rsi, -32(%rbp)
	movl	$0, -12(%rbp)
	jmp	.L16
.L19:
	movl	$0, -8(%rbp)
	jmp	.L17
.L18:
	movl	-12(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	addq	-32(%rbp), %rax
	movl	-8(%rbp), %edx
	movslq	%edx, %rdx
	movl	(%rax,%rdx,4), %eax
	movl	%eax, -4(%rbp)
	movl	-12(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	movq	%rax, %rcx
	addq	-32(%rbp), %rcx
	movl	-8(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	addq	-32(%rbp), %rax
	movl	-12(%rbp), %edx
	movslq	%edx, %rdx
	movl	(%rax,%rdx,4), %edx
	movl	-8(%rbp), %eax
	cltq
	movl	%edx, (%rcx,%rax,4)
	movl	-8(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	addq	-32(%rbp), %rax
	movl	-12(%rbp), %edx
	movslq	%edx, %rdx
	movl	-4(%rbp), %ecx
	movl	%ecx, (%rax,%rdx,4)
	addl	$1, -8(%rbp)
.L17:
	movl	-8(%rbp), %eax
	cmpl	-12(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L18
	addl	$1, -12(%rbp)
.L16:
	movl	-12(%rbp), %eax
	cmpl	-20(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L19
	movl	$.LC7, %edi
	call	puts
	movl	$0, -12(%rbp)
	jmp	.L20
.L23:
	movl	$0, -8(%rbp)
	jmp	.L21
.L22:
	movl	-12(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	addq	-32(%rbp), %rax
	movl	-8(%rbp), %edx
	movslq	%edx, %rdx
	movl	(%rax,%rdx,4), %eax
	movl	%eax, %esi
	movl	$.LC5, %edi
	movl	$0, %eax
	call	printf
	addl	$1, -8(%rbp)
.L21:
	movl	-8(%rbp), %eax
	cmpl	-20(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L22
	movl	$10, %edi
	call	putchar
	addl	$1, -12(%rbp)
.L20:
	movl	-12(%rbp), %eax
	cmpl	-20(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L23
	leave
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE2:
	.size	_Z15TransposeMatrixiPA20_i, .-_Z15TransposeMatrixiPA20_i
	.globl	_Z14VectorMultiplyiPiS_
	.type	_Z14VectorMultiplyiPiS_, @function
_Z14VectorMultiplyiPiS_:
.LFB3:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -20(%rbp)
	movq	%rsi, -32(%rbp)
	movq	%rdx, -40(%rbp)
	movl	$0, -4(%rbp)
	movl	$0, -8(%rbp)
	jmp	.L25
.L26:
	movl	-8(%rbp), %eax
	cltq
	salq	$2, %rax
	addq	-32(%rbp), %rax
	movl	(%rax), %edx
	movl	-8(%rbp), %eax
	cltq
	salq	$2, %rax
	addq	-40(%rbp), %rax
	movl	(%rax), %eax
	imull	%edx, %eax
	addl	%eax, -4(%rbp)
	addl	$1, -8(%rbp)
.L25:
	movl	-8(%rbp), %eax
	cmpl	-20(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L26
	movl	-4(%rbp), %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE3:
	.size	_Z14VectorMultiplyiPiS_, .-_Z14VectorMultiplyiPiS_
	.globl	_Z14MultiplyMatrixiPA20_iS0_S0_
	.type	_Z14MultiplyMatrixiPA20_iS0_S0_, @function
_Z14MultiplyMatrixiPA20_iS0_S0_:
.LFB4:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	pushq	%rbx
	subq	$56, %rsp
	movl	%edi, -36(%rbp)
	movq	%rsi, -48(%rbp)
	movq	%rdx, -56(%rbp)
	movq	%rcx, -64(%rbp)
	movq	-56(%rbp), %rdx
	movl	-36(%rbp), %eax
	movq	%rdx, %rsi
	movl	%eax, %edi
	.cfi_offset 3, -24
	call	_Z15TransposeMatrixiPA20_i
	movl	$0, -24(%rbp)
	jmp	.L28
.L31:
	movl	$0, -20(%rbp)
	jmp	.L29
.L30:
	movl	-24(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	movq	%rax, %rbx
	addq	-64(%rbp), %rbx
	movl	-20(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	addq	-56(%rbp), %rax
	movq	%rax, %rsi
	movl	-24(%rbp), %eax
	movslq	%eax, %rdx
	movq	%rdx, %rax
	salq	$2, %rax
	addq	%rdx, %rax
	salq	$4, %rax
	addq	-48(%rbp), %rax
	movq	%rax, %rcx
	movl	-36(%rbp), %eax
	movq	%rsi, %rdx
	movq	%rcx, %rsi
	movl	%eax, %edi
	call	_Z14VectorMultiplyiPiS_
	movl	-20(%rbp), %edx
	movslq	%edx, %rdx
	movl	%eax, (%rbx,%rdx,4)
	addl	$1, -20(%rbp)
.L29:
	movl	-20(%rbp), %eax
	cmpl	-36(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L30
	addl	$1, -24(%rbp)
.L28:
	movl	-24(%rbp), %eax
	cmpl	-36(%rbp), %eax
	setl	%al
	testb	%al, %al
	jne	.L31
	addq	$56, %rsp
	popq	%rbx
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE4:
	.size	_Z14MultiplyMatrixiPA20_iS0_S0_, .-_Z14MultiplyMatrixiPA20_iS0_S0_
	.ident	"GCC: (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3"
	.section	.note.GNU-stack,"",@progbits
